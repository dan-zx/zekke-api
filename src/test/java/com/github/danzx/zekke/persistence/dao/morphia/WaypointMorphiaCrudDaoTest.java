/*
 * Copyright 2017 Daniel Pedraza-Arcega
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.github.danzx.zekke.persistence.dao.morphia;

import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.toList;

import static com.github.danzx.zekke.domain.BoundingBox.ofBottomTop;

import static org.assertj.core.api.Assertions.assertThat;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import javax.inject.Inject;

import com.github.danzx.zekke.data.filter.waypoint.LocationWaypointFilterOptions;
import com.github.danzx.zekke.data.filter.waypoint.WaypointFilterOptions;
import com.github.danzx.zekke.domain.Coordinates;
import com.github.danzx.zekke.domain.Waypoint;
import com.github.danzx.zekke.domain.Waypoint.Type;
import com.github.danzx.zekke.test.mongo.BaseSpringMongoTest;

import junitparams.JUnitParamsRunner;
import junitparams.Parameters;

import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(JUnitParamsRunner.class)
public class WaypointMorphiaCrudDaoTest extends BaseSpringMongoTest {

    private static final long CDMX_ID = 1L;
    private static final long QRO_ID = 2L;
    private static final long GDL_ID = 4L;
    private static final long LEON_ID = 5L;
    private static final long NOT_EXITING_WAYPOINT = Long.MAX_VALUE;
    private static final Map<Long, Waypoint> DATA = buildStoredData();

    @Inject private WaypointMorphiaCrudDao waypointDao;

    @Override
    public void before() throws Exception {
        super.before();
        assertThat(waypointDao).isNotNull();
        assertThat(waypointDao.getDatastore()).isNotNull();
        assertThat(waypointDao.getCollectionClass()).isNotNull();
    }

    @Test
    public void shouldReturnWaypointWhenFindByAnExistingId() {
        Waypoint waypoint = DATA.get(3L);
        Optional<Waypoint> waypointGot = waypointDao.findById(3L);
        assertThat(waypointGot.isPresent()).isTrue();
        assertThat(waypointGot.get()).isEqualTo(waypoint);
    }

    @Test
    public void shouldReturnEmptyOptionalWhenFindByIdHasInvalidId() {
        Optional<Waypoint> waypoint = waypointDao.findById(NOT_EXITING_WAYPOINT);
        assertThat(waypoint.isPresent()).isFalse();
    }

    @Test
    public void shouldDeleteWaypointAndReturnAnEmptyOptionalWhenFindByTheDeletedId() {
        assertThat(waypointDao.deleteById(CDMX_ID)).isTrue();
        Optional<Waypoint> waypoint = waypointDao.findById(CDMX_ID);
        assertThat(waypoint.isPresent()).isFalse();
    }

    @Test
    public void shouldPerformDeleteWithUnexistingWaypointAndNotFailing() {
        assertThat(waypointDao.deleteById(NOT_EXITING_WAYPOINT)).isFalse();
    }

    @Test
    public void shouldSaveWaypointAndReturnTheSameWaypointWhenFindByTheNewId() {
        Waypoint newWalkway = newWaypoint(666L, null, Type.WALKWAY, 55.3691, -70.1439);
        waypointDao.saveOrUpdate(newWalkway);
        Optional<Waypoint> waypoint = waypointDao.findById(newWalkway.getId());
        assertThat(waypoint.isPresent()).isTrue();
        assertThat(waypoint.get()).isEqualTo(newWalkway);
    }

    @Test
    public void shouldSaveWaypointAndSetAutogeneratedId() {
        Waypoint newWalkway = newWaypoint(null, "Somewhere", Type.POI, 55.3691, -70.1439);
        assertThat(newWalkway.getId()).isNull();
        waypointDao.saveOrUpdate(newWalkway);
        assertThat(newWalkway.getId()).isNotNull();
        Optional<Waypoint> waypoint = waypointDao.findById(newWalkway.getId());
        assertThat(waypoint.isPresent()).isTrue();
        assertThat(waypoint.get()).isEqualTo(newWalkway);
    }

    @Test
    public void shouldUpdateExistingWaypoint() {
        Waypoint waypointToUpdate = waypointDao.findById(CDMX_ID).get();
        waypointToUpdate.setName("other Name");
        waypointToUpdate.setLocation(Coordinates.ofLatLng(12.63, 85.243));
        waypointDao.saveOrUpdate(waypointToUpdate);

        Waypoint updatedWaypoint = waypointDao.findById(waypointToUpdate.getId()).get();
        assertThat(updatedWaypoint).isEqualTo(waypointToUpdate);
    }

    @Test
    @Parameters(method = "waypointFiltersAndFilteredResults")
    public void shouldFindWaypointsFiltered(WaypointFilterOptions filterOptions, List<Waypoint> expected) {
        List<Waypoint> actual = waypointDao.findFiltered(filterOptions);
        assertThat(actual).isNotNull().hasSameSizeAs(expected).containsOnlyElementsOf(expected);
    }

    @Test
    @Parameters(method = "waypointLocationFiltersAndFilteredResults")
    public void shouldFindWaypointNearALocationFiltered(LocationWaypointFilterOptions filterOptions, List<Waypoint> expected) {
        List<Waypoint> actual = waypointDao.findNearALocationFiltered(filterOptions);
        assertThat(actual).isNotNull().hasSameSizeAs(expected).containsOnlyElementsOf(expected);
    }

    public Object[] waypointFiltersAndFilteredResults() {
        List<Waypoint> walkways = DATA.values()
                .stream()
                .filter(waypoint -> waypoint.getType() == Type.WALKWAY)
                .collect(toList());
        List<Waypoint> poisContainingAraInName = DATA.values()
                .stream()
                .filter(waypoint -> waypoint.getType() == Type.POI)
                .filter(waypoint -> waypoint.getName().map(name -> name.contains("ara")).orElse(false))
                .collect(toList());
        List<Waypoint> allWaypoints = new ArrayList<>(DATA.values());
        List<Waypoint> allWaypointsOnlyWithIdAndName = DATA.values()
                .stream()
                .map(this::toWaypointWithOnlyIdAndName)
                .collect(toList());
        List<Waypoint> poisOnlyWithIdAndName = DATA.values()
                .stream()
                .filter(waypoint -> waypoint.getType() == Type.POI)
                .map(this::toWaypointWithOnlyIdAndName)
                .collect(toList());
        List<Waypoint> allWaypointsLimitingTo2Results = DATA.values()
                .stream()
                .limit(2)
                .collect(toList());
        return new Object[][] {
            {new WaypointFilterOptions.Builder().byType(Type.WALKWAY).build(), walkways},
            {new WaypointFilterOptions.Builder().byType(Type.POI).withNameContaining("ara").build(), poisContainingAraInName},
            {new WaypointFilterOptions.Builder().withNameContaining("ara").build(), poisContainingAraInName},
            {new WaypointFilterOptions.Builder().build(), allWaypoints},
            {new WaypointFilterOptions.Builder().byType(Type.POI).onlyIdAndName().build(), poisOnlyWithIdAndName},
            {new WaypointFilterOptions.Builder().onlyIdAndName().build(), allWaypointsOnlyWithIdAndName},
            {new WaypointFilterOptions.Builder().limitResulsTo(2).build(), allWaypointsLimitingTo2Results},
            {
                new WaypointFilterOptions.Builder()
                    .withinBoundingBox(ofBottomTop(Coordinates.ofLatLng(19.437943, -104.018555), Coordinates.ofLatLng(21.373642, -100.832520)))
                    .build(),
                asList(DATA.get(GDL_ID), DATA.get(LEON_ID), DATA.get(3L), DATA.get(6L))
            },
            {
                new WaypointFilterOptions.Builder()
                    .withinBoundingBox(ofBottomTop(Coordinates.ofLatLng(20.794313, -99.052734), Coordinates.ofLatLng(21.347903, -98.591309)))
                    .build(),
                emptyList()
            },
            {
                new WaypointFilterOptions.Builder()
                    .withinBoundingBox(ofBottomTop(Coordinates.ofLatLng(19.437943, -104.018555), Coordinates.ofLatLng(21.373642, -100.832520)))
                    .byType(Type.WALKWAY)
                    .build(),
                asList(DATA.get(3L), DATA.get(6L))
            },
            {
                new WaypointFilterOptions.Builder()
                    .withinBoundingBox(ofBottomTop(Coordinates.ofLatLng(20.794313, -99.052734), Coordinates.ofLatLng(21.347903, -98.591309)))
                    .byType(Type.WALKWAY)
                    .build(),
                emptyList()
            },
            {
                new WaypointFilterOptions.Builder()
                    .withinBoundingBox(ofBottomTop(Coordinates.ofLatLng(20.465294, -103.491211), Coordinates.ofLatLng(21.204578, -101.491699)))
                    .byType(Type.POI)
                    .build(),
                asList(DATA.get(GDL_ID), DATA.get(LEON_ID))
            },
            {
                new WaypointFilterOptions.Builder()
                    .withinBoundingBox(ofBottomTop(Coordinates.ofLatLng(20.465294, -103.491211), Coordinates.ofLatLng(21.204578, -101.491699)))
                    .byType(Type.POI)
                    .withNameContaining("ara")
                    .build(),
                asList(DATA.get(GDL_ID))
            },
            {
                new WaypointFilterOptions.Builder()
                    .withinBoundingBox(ofBottomTop(Coordinates.ofLatLng(20.794313, -99.052734), Coordinates.ofLatLng(21.347903, -98.591309)))
                    .byType(Type.POI)
                    .withNameContaining("ara")
                    .build(),
                emptyList()
            },
            {
                new WaypointFilterOptions.Builder()
                    .withinBoundingBox(ofBottomTop(Coordinates.ofLatLng(20.465294, -103.491211), Coordinates.ofLatLng(21.204578, -101.491699)))
                    .byType(Type.POI)
                    .onlyIdAndName()
                    .build(),
                asList(DATA.get(GDL_ID), DATA.get(LEON_ID)).stream().map(this::toWaypointWithOnlyIdAndName).collect(toList())
            },
            {
                new WaypointFilterOptions.Builder()
                    .withinBoundingBox(ofBottomTop(Coordinates.ofLatLng(20.465294, -103.491211), Coordinates.ofLatLng(21.204578, -101.491699)))
                    .byType(Type.POI)
                    .withNameContaining("ara")
                    .onlyIdAndName()
                    .build(),
                asList(DATA.get(GDL_ID)).stream().map(this::toWaypointWithOnlyIdAndName).collect(toList())
            },
            {
                new WaypointFilterOptions.Builder()
                    .withinBoundingBox(ofBottomTop(Coordinates.ofLatLng(20.794313, -99.052734), Coordinates.ofLatLng(21.347903, -98.591309)))
                    .byType(Type.POI)
                    .withNameContaining("ara")
                    .onlyIdAndName()
                    .build(),
                emptyList()
            }
        };
    }

    public Object[] waypointLocationFiltersAndFilteredResults() {
        return new Object[][] {
            {
                LocationWaypointFilterOptions.Builder
                    .nearLocation(Coordinates.ofLatLng(19.758788, -99.437256))
                    .byType(Type.POI)
                    .maximumSearchDistance(180_000)
                    .limitResulsTo(1)
                    .build(),
                asList(DATA.get(CDMX_ID))
            },
            {
                LocationWaypointFilterOptions.Builder
                    .nearLocation(Coordinates.ofLatLng(19.758788, -99.437256))
                    .byType(Type.WALKWAY)
                    .maximumSearchDistance(180_000)
                    .limitResulsTo(1)
                    .build(),
                asList(DATA.get(7L))
            },
            {
                LocationWaypointFilterOptions.Builder
                    .nearLocation(Coordinates.ofLatLng(19.758788, -99.437256))
                    .maximumSearchDistance(100_000)
                    .build(),
                asList(DATA.get(CDMX_ID), DATA.get(7L))
            },
            {
                LocationWaypointFilterOptions.Builder
                    .nearLocation(Coordinates.ofLatLng(19.387585, -99.050937))
                    .maximumSearchDistance(1)
                    .build(),
                emptyList()
            },
        };
    }

    private Waypoint toWaypointWithOnlyIdAndName(Waypoint waypoint) {
        return newWaypoint(waypoint.getId(), waypoint.getName().orElse(null), null, null, null);
    }

    private static Map<Long, Waypoint> buildStoredData() {
        Map<Long, Waypoint> data = new HashMap<>();
        data.put(1L, newWaypoint(CDMX_ID, "Ciudad de Mexico", Type.POI, 19.387591, -99.052734));
        data.put(2L, newWaypoint(QRO_ID, "Queretaro", Type.POI, 20.579760, -100.371094));
        data.put(3L, newWaypoint(3L, null, Type.WALKWAY, 19.672009, -101.151123));
        data.put(4L, newWaypoint(GDL_ID, "Guadalajara", Type.POI, 20.651740, -103.337402));
        data.put(5L, newWaypoint(LEON_ID, "Leon", Type.POI, 21.123896, -101.667480));
        data.put(6L, newWaypoint(6L, null, Type.WALKWAY, 20.651740, -101.359863));
        data.put(7L, newWaypoint(7L, null, Type.WALKWAY, 19.920099, -99.788818));
        return data;
    }

    private static Waypoint newWaypoint(Long id, String name, Type type, Double lat, Double lng) {
        Waypoint waypoint = new Waypoint();
        if (id != null) waypoint.setId(id);
        if (name != null) waypoint.setName(name);
        if (type != null) waypoint.setType(type);
        if (lat != null && lng != null) waypoint.setLocation(Coordinates.ofLatLng(lat, lng));
        return waypoint;
    }
}
